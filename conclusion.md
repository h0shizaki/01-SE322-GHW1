# Conclusion
| Student No. | References |
|---|---|
|003|5|
|009|5|
|025|5|
|032|5|
|033|5|
|042|5|
|046|5|
|047|5|
#### Total references: 40
## Problems
- **Problem 1**: Access ([s05-033](./memo/s05-033.md))
	- Synchronization mechanisms can be used to ensure that only one thread can access and modify shared data at a time. this can prevent data corruption or inconsistent states. ([s05-033](./memo/s05-033.md))
- **Problem 2**: Access to uncommitted data ([s02-003](./memo/s02-003.md))
	- Currently committed semantics. ([s02-003](./memo/s02-003.md))
- **Problem 3**: Additional performance overheads and complexities in os are needed for switching between application ([s05-042](./memo/s05-042.md))
- **Problem 4**: Atomicity violation ([s03-032](./memo/s03-032.md))
	- Transactional memory : provides a higher-level abstraction for atomic operations. allows a group of operations to be treated as a single transaction, ensuring that either all the operations within the transaction succeed or none of them do. ([s03-032](./memo/s03-032.md))
	- Locking : use locking mechanisms, such as locks or mutexes, to enforce mutual exclusion and ensure that only one thread can access the shared resource at a time. ([s03-032](./memo/s03-032.md))
	- Testing and debugging : use appropriate testing techniques, such as stress testing, to simulate concurrent scenarios and ensure that atomicity is maintained under various conditions. ([s03-032](./memo/s03-032.md))
- **Problem 5**: Blocking ([s05-042](./memo/s05-042.md))
- **Problem 6**: Busy waiting ([s04-032](./memo/s04-032.md))
	- Sleep or yield : instead of continuously looping and checking the condition, a thread can be put to sleep or yield its execution to allow other threads to run. ([s04-032](./memo/s04-032.md))
	- Blocking or condition variables : use blocking or condition variables to suspend the execution of a thread until a specific condition is met. ([s04-032](./memo/s04-032.md))
	- Use a higher-level concurrency control mechanism : employ higher-level concurrency control mechanisms, such as locks, monitors, or semaphores, to coordinate the execution of multiple threads. ([s04-032](./memo/s04-032.md))
- **Problem 7**: Channel direction ([s02-042](./memo/s02-042.md))
	- Specify a direction on a channel type thus restricting it to either sending or receiving. ([s02-042](./memo/s02-042.md))
- **Problem 8**: Communicating data for spawning a fiber is not executed ([s04-042](./memo/s04-042.md))
	- Do a sleep: because the sleep call will schedule the main fiber to be executed in a given second, and then executes another" ready to execute" fiber. ([s04-042](./memo/s04-042.md))
- **Problem 9**: Concurrency bugs are some of the hardest bugs to find and fix ([s01-042](./memo/s01-042.md))
	- Require careful design to avoid. ([s01-042](./memo/s01-042.md))
- **Problem 10**: Data corruption ([s05-046](./memo/s05-046.md))
	- Use thread-safe methods. ([s05-046](./memo/s05-046.md))
- **Problem 11**: Data versioning issue ([s05-003](./memo/s05-003.md))
	- Using transactional programming language(t-sql) for sql database. ([s05-003](./memo/s05-003.md))
	- Apply procedures and triggers for nosql database. ([s05-003](./memo/s05-003.md))
- **Problem 12**: Deadlock ([s01-003](./memo/s01-003.md), [s01-046](./memo/s01-046.md), [s02-025](./memo/s02-025.md), [s03-003](./memo/s03-003.md), [s03-046](./memo/s03-046.md), [s04-047](./memo/s04-047.md), [s05-042](./memo/s05-042.md))
	- Algorithm (eg. all-or-none resource allocation algorithm, banker's algorithm, wait/die and would/wait). ([s01-003](./memo/s01-003.md))
	- Removing the hold and wait condition. ([s01-003](./memo/s01-003.md))
	- Removing the mutual exclusion condition. ([s01-003](./memo/s01-003.md))
	- Spend resources to either avoid or kill deadlocked processes. ([s01-046](./memo/s01-046.md))
	- Let it happen because it's very rare. (can be cleaned up by restarting the system). ([s01-046](./memo/s01-046.md))
	- Changing the order of the locks. ([s02-025](./memo/s02-025.md))
	- Time outs and detection. ([s03-003](./memo/s03-003.md))
	- Forcing. ([s03-003](./memo/s03-003.md))
	- Spend resources to either avoid or kill deadlocked processes. ([s03-046](./memo/s03-046.md))
	- In es6, promises can help you manage the order in which your asynchronous operations are executed. you can chain promises together using the then() method, which allows you to specify what should happen after the promise has resolved. ([s04-047](./memo/s04-047.md))
	- Software and hardware locks are commonly used to arbitrate shared resources and implement process synchronization in parallel computing, distributed systems, and multiprocessing. ([s05-042](./memo/s05-042.md))
- **Problem 13**: Dealing the need for programs to run smaller components simultaneously, such as handling multiple requests in a web server ([s02-042](./memo/s02-042.md))
	- The context provides code examples to demonstrate the usage of goroutines and channels in achieving concurrency and synchronization. ([s02-042](./memo/s02-042.md))
- **Problem 14**: Dining philosopher ([s03-047](./memo/s03-047.md))
	- Using a lock per philosopher: each philosopher is given a lock. when a philosopher wants to pick up a fork, they must first acquire the lock for that fork and the lock for the adjacent fork. once both locks are acquired, the philosopher can pick up both forks and eat. this method guarantees that no two philosophers can eat simultaneously, but it can lead to a deadlock if all philosophers try to simultaneously acquire the lock for the first fork. ([s03-047](./memo/s03-047.md))
	- Using a global lock: a single lock is shared by all philosophers. when a philosopher wants to pick up a fork, they must first acquire the global lock. once the global lock is obtained, the philosopher can pick up both forks and eat. this method guarantees that no two philosophers can eat at the same time, but it can lead to starvation if the global lock is always held. ([s03-047](./memo/s03-047.md))
- **Problem 15**: Dirty read ([s01-047](./memo/s01-047.md), [s02-009](./memo/s02-009.md), [s03-009](./memo/s03-009.md), [s05-025](./memo/s05-025.md), [s05-047](./memo/s05-047.md))
	- To ensure consistency of the database, it is very important to prevent the occurrence of above problems. ([s01-047](./memo/s01-047.md))
	- Read committed or serializable, to ensure that transactions only read committed data. ([s02-009](./memo/s02-009.md))
	- Prevent them from accessing uncommitted or intermediate data. ([s02-009](./memo/s02-009.md))
	- Using the read committed isolation level ensures that a transaction only reads data that has been committed by other transactions, avoiding dirty reads. ([s03-009](./memo/s03-009.md))
	- Read committed level : only allowing a transaction to read changes that have been commited by other transactions. ([s05-025](./memo/s05-025.md))
	- Concurrency control protocols  ensure consistency , atomicity, isolation, and serializability of concurrent transactions in a database. the concurrency control protocol  can be any of the following type. ([s05-047](./memo/s05-047.md))
	- Lock based concurrency control protocol. ([s05-047](./memo/s05-047.md))
	- Time-stamp concurrency control protocol. ([s05-047](./memo/s05-047.md))
	- Validation based concurrency control protocol. ([s05-047](./memo/s05-047.md))
- **Problem 16**: Dirty read problem ([s02-046](./memo/s02-046.md))
	- Lock the resource while it is under operation. ([s02-046](./memo/s02-046.md))
	- Implement timestamping and allow or reject transactions based on the timestamps. ([s02-046](./memo/s02-046.md))
	- Implement validation protocol. ([s02-046](./memo/s02-046.md))
- **Problem 17**: Eternal lock resource ([s04-003](./memo/s04-003.md))
	- Adding timeout to the lock. ([s04-003](./memo/s04-003.md))
- **Problem 18**: Execution of a program for communicating data with event loop ([s04-042](./memo/s04-042.md))
	- Some time-consuming operations are delegated. ([s04-042](./memo/s04-042.md))
- **Problem 19**: Fuzzy read ([s01-032](./memo/s01-032.md))
	- Use locking mechanisms to ensure that concurrent transactions do not interfere with each other. ([s01-032](./memo/s01-032.md))
	- Keep two concurrent transactions accessing two columns of the same record/value. ([s01-032](./memo/s01-032.md))
	- Modified the transaction to manipulate consistent data. ([s01-032](./memo/s01-032.md))
- **Problem 20**: Goroutines run in order rather than simultaneously ([s02-042](./memo/s02-042.md))
	- Add some delay to the function using time.sleep and rand.intn:. ([s02-042](./memo/s02-042.md))
- **Problem 21**: Heisenbug ([s01-042](./memo/s01-042.md))
	- Try to look at it with 'println' or 'debugger'. ([s01-042](./memo/s01-042.md))
- **Problem 22**: Inconsistent read ([s03-003](./memo/s03-003.md))
	- Controlling access. ([s03-003](./memo/s03-003.md))
	- Temporal reading. ([s03-003](./memo/s03-003.md))
- **Problem 23**: Inconsistent retrieval ([s04-025](./memo/s04-025.md))
- **Problem 24**: Incorrect summary ([s02-047](./memo/s02-047.md), [s03-009](./memo/s03-009.md))
	- Timestamp ordering assigns a unique timestamp to each transaction and ensures that transactions execute in timestamp order. timestamp ordering can prevent non-repeatable read and phantom read. ([s02-047](./memo/s02-047.md))
	- Use read-write locks to allow concurrent read access to the summary while ensuring exclusive write access. ([s03-009](./memo/s03-009.md))
- **Problem 25**: Incorrect update ([s03-009](./memo/s03-009.md))
	- Using version numbers or timestamps, to detect conflicts during transaction commit. before committing a transaction, check if the data being modified has been updated by another transaction since it was read. ([s03-009](./memo/s03-009.md))
- **Problem 26**: It is necessary to protect multiple applications from each other ([s05-042](./memo/s05-042.md))
- **Problem 27**: It is necessary to use extra techniques to coordinate several application ([s05-042](./memo/s05-042.md))
- **Problem 28**: Limits of concurrency gain ([s05-033](./memo/s05-033.md))
	- Amdahl's law is a rule that calculates the maximum performance gain from parallel execution. it states that the maximum speedup achievable is limited by the proportion of the program that cannot be parallelized. ([s05-033](./memo/s05-033.md))
- **Problem 29**: Locating the programming error ([s05-042](./memo/s05-042.md))
- **Problem 30**: Locking read ([s01-032](./memo/s01-032.md))
	- Maintain two variables: readerscount and writerscount, both initialized to 0. ([s01-032](./memo/s01-032.md))
	- Use a mutex lock, often referred to as mutex, to protect the critical section where the counters are modified. ([s01-032](./memo/s01-032.md))
- **Problem 31**: Locking the channel ([s05-042](./memo/s05-042.md))
- **Problem 32**: Loss of synchronization ([s04-046](./memo/s04-046.md))
	- Pass synchronized resources by reference. ([s04-046](./memo/s04-046.md))
- **Problem 33**: Lost update ([s01-047](./memo/s01-047.md), [s02-003](./memo/s02-003.md), [s02-009](./memo/s02-009.md), [s02-047](./memo/s02-047.md), [s03-003](./memo/s03-003.md), [s04-025](./memo/s04-025.md), [s05-025](./memo/s05-025.md), [s05-047](./memo/s05-047.md))
	- Currently committed semantics. ([s02-003](./memo/s02-003.md))
	- Use transaction isolation levels to control concurrent access to the data. ([s02-009](./memo/s02-009.md))
	- Optimistic concurrency control assumes that conflicts between transactions are rare and allows transactions to proceed without acquiring locks initially. if a conflict is detected, the transaction is rolled back, and the conflict is resolved. optimistic concurrency control can prevent dirty read, non-repeatable read, and phantom read. ([s02-047](./memo/s02-047.md))
	- Isolation. ([s03-003](./memo/s03-003.md))
	- Immutability. ([s03-003](./memo/s03-003.md))
	- Optimistic locking. ([s03-003](./memo/s03-003.md))
	- Pessimistic locking. ([s03-003](./memo/s03-003.md))
	- Increase transaction isolation level. ([s04-025](./memo/s04-025.md))
	- Optimistic locking. ([s04-025](./memo/s04-025.md))
	- Possimistic locking. ([s04-025](./memo/s04-025.md))
	- Atomic write operations. ([s04-025](./memo/s04-025.md))
	- Use atomic operations. ([s05-025](./memo/s05-025.md))
	- Use lock. ([s05-025](./memo/s05-025.md))
	- Repeatable read is required to perevent lost updates, which use shared locks to prevent other transaction from modifying the data. ([s05-025](./memo/s05-025.md))
	- Concurrency control protocols  ensure consistency , atomicity, isolation, and serializability of concurrent transactions in a database. the concurrency control protocol  can be any of the following type. ([s05-047](./memo/s05-047.md))
	- Lock based concurrency control protocol. ([s05-047](./memo/s05-047.md))
	- Time-stamp concurrency control protocol. ([s05-047](./memo/s05-047.md))
	- Validation based concurrency control protocol. ([s05-047](./memo/s05-047.md))
- **Problem 34**: Lost update problem ([s02-046](./memo/s02-046.md))
	- Lock the resource while it is under operation. ([s02-046](./memo/s02-046.md))
	- Implement timestamping and allow or reject transactions based on the timestamps. ([s02-046](./memo/s02-046.md))
	- Implement validation protocol. ([s02-046](./memo/s02-046.md))
- **Problem 35**: Lost updated when two users attempt to update the same piece of data at the same time ([s03-025](./memo/s03-025.md))
	- Locking : locking techniques are commonly use to protect lost update in database, but not at all dbms support report locking. ([s03-025](./memo/s03-025.md))
	- Read before write : it saving the initial state of a record before making change and comparing with the current stae before updating the database. this technique avoids blocking problem and prioritize when the user makes change quickly. ([s03-025](./memo/s03-025.md))
	- Timestamping : maintaing a last modified date/time field in record, which is updated whenever a record is inserted or updated by comparing the timestamp of a record with the previously saved timestamp. ([s03-025](./memo/s03-025.md))
- **Problem 36**: Memory consistency ([s03-046](./memo/s03-046.md))
	- Use `volatile` keyword in supported languages. ([s03-046](./memo/s03-046.md))
	- Use atomic operations. ([s03-046](./memo/s03-046.md))
	- Implement resource lock. ([s03-046](./memo/s03-046.md))
- **Problem 37**: Misunderstanding of race condition ([s01-009](./memo/s01-009.md))
	- Ensure shared data is accessed and modified in a synchronized manner. this generally involves using a synchronization structure and carefully designing concurrency programs. by considering the potential of race conditions. ([s01-009](./memo/s01-009.md))
- **Problem 38**: Misusing lock ([s03-046](./memo/s03-046.md))
	- Use resource locks appropriately. ([s03-046](./memo/s03-046.md))
- **Problem 39**: Misusing of wait ([s04-046](./memo/s04-046.md))
	- Study how waits and workgroup waits work in your language. ([s04-046](./memo/s04-046.md))
- **Problem 40**: Mongodb doesn't guarantee acid compliance ([s04-003](./memo/s04-003.md))
	- Modify the database schema to collect information to single document for using atomic function and locking mechanism. ([s04-003](./memo/s04-003.md))
	- Use another database to conjunction with mongodb. ([s04-003](./memo/s04-003.md))
- **Problem 41**: Non-atomic ([s05-042](./memo/s05-042.md))
- **Problem 42**: Non-repeatable data ([s02-003](./memo/s02-003.md))
	- Set the thread isolation level. ([s02-003](./memo/s02-003.md))
- **Problem 43**: Optimal allocation of resource ([s05-042](./memo/s05-042.md))
- **Problem 44**: Over-parallelization ([s05-046](./memo/s05-046.md))
	- Evaluate if sub-problems are worth parallelizing considering the overhead. ([s05-046](./memo/s05-046.md))
- **Problem 45**: Parallelism may come out slower ([s05-046](./memo/s05-046.md))
	- Avoid using too many thread-safe method as thread-safe methods can be slower. ([s05-046](./memo/s05-046.md))
	- Test both sequential and parallel approach and measure. ([s05-046](./memo/s05-046.md))
- **Problem 46**: Phantom read ([s01-047](./memo/s01-047.md), [s02-003](./memo/s02-003.md), [s02-047](./memo/s02-047.md), [s05-025](./memo/s05-025.md), [s05-047](./memo/s05-047.md))
	- Currently committed semantics. ([s02-003](./memo/s02-003.md))
	- Set the thread isolation level. ([s02-003](./memo/s02-003.md))
	- Concurrency control protocols  ensure consistency , atomicity, isolation, and serializability of concurrent transactions in a database. the concurrency control protocol  can be any of the following type. ([s05-047](./memo/s05-047.md))
	- Lock based concurrency control protocol. ([s05-047](./memo/s05-047.md))
	- Time-stamp concurrency control protocol. ([s05-047](./memo/s05-047.md))
	- Validation based concurrency control protocol. ([s05-047](./memo/s05-047.md))
- **Problem 47**: Priority inversion ([s02-025](./memo/s02-025.md), [s02-032](./memo/s02-032.md))
	- Disabling all interrupts to protect critical sections. ([s02-032](./memo/s02-032.md))
	- Priority ceiling protocol : the shared mutex process has a characteristic (high) priority of its own, which is assigned to the task of locking the mutex. ([s02-032](./memo/s02-032.md))
	- Priority inheritance : whenever a high-priority task has to wait for some resource shared with an executing low-priority task, the low-priority task is temporarily assigned the priority of the highest waiting priority task for the duration of its own use of the shared resource. ([s02-032](./memo/s02-032.md))
	- Random boosting : ready tasks holding locks are randomly boosted in priority until they exit the critical section. ([s02-032](./memo/s02-032.md))
	- Avoid blocking : using non-blocking algorithms such as read-copy-update. ([s02-032](./memo/s02-032.md))
- **Problem 48**: Producer consumer ([s03-047](./memo/s03-047.md))
	- Shared memory: in this method, the producer and consumer share a common memory space. the producer produces data and stores it in the shared memory. the consumer then consumes the data from the shared memory. ([s03-047](./memo/s03-047.md))
	- Message passing: in this method, the producer and consumer communicate with each other through message passing. the producer produces data and sends it to the consumer through a message. the consumer then consumes the data and sends a reply message to the producer. ([s03-047](./memo/s03-047.md))
	- Database: in this method, the producer and consumer access a shared database. the producer produces data and stores it in the database. the consumer then consumes the data from the database. ([s03-047](./memo/s03-047.md))
- **Problem 49**: Race condition ([s01-046](./memo/s01-046.md), [s02-025](./memo/s02-025.md), [s03-046](./memo/s03-046.md), [s04-046](./memo/s04-046.md), [s04-047](./memo/s04-047.md), [s05-042](./memo/s05-042.md))
	- Implement resource locks or avoid race condition altogether. ([s01-046](./memo/s01-046.md))
	- Avoid using shared state, e.g. variables. ([s01-046](./memo/s01-046.md))
	- Use atomic operations. ([s01-046](./memo/s01-046.md))
	- Using a synchronized block of java code, locks or atomic variables like java.util.concurrent.atomic.atomicinteger. ([s02-025](./memo/s02-025.md))
	- Use thread-safe data type. ([s03-046](./memo/s03-046.md))
	- Avoid race condition altogether. ([s03-046](./memo/s03-046.md))
	- Use atomic operations. ([s03-046](./memo/s03-046.md))
	- Implement resource lock. ([s03-046](./memo/s03-046.md))
	- Use resource lock. ([s04-046](./memo/s04-046.md))
	- Use channels (in supported languages). ([s04-046](./memo/s04-046.md))
	- Blocking code (i.e. using `time.sleep`, or wait). ([s04-046](./memo/s04-046.md))
	- Not mutating resources while a thread, or in this case, go routine, requires it. ([s04-046](./memo/s04-046.md))
	- In es5, race conditions are commonly handled by using techniques such as locks, semaphores, and message queues to synchronize access to shared resources. developers can implement mutex locks or semaphores to ensure that only one process can access a critical section of code at a time, preventing multiple processes from writing or reading from the same resource simultaneously. ([s04-047](./memo/s04-047.md))
- **Problem 50**: Resource contention ([s05-032](./memo/s05-032.md))
	- Read-write locks : when the shared resource is primarily read, but occasional writes occur, use read-write locks. read operations can be executed concurrently, while write operations are performed exclusively, minimizing contention. ([s05-032](./memo/s05-032.md))
	- Caching and prefetching : utilize caching and prefetching techniques to reduce the frequency of accessing the shared resource directly. ([s05-032](./memo/s05-032.md))
	- Resource pooling : implement resource pooling, where a limited set of resources is shared among multiple threads. ([s05-032](./memo/s05-032.md))
- **Problem 51**: Shared state & race condition ([s05-046](./memo/s05-046.md))
	- Use less shared state, i.e. `static` variables. ([s05-046](./memo/s05-046.md))
	- Use functions that store thread-local state, i.e. c# `parellel.for`. ([s05-046](./memo/s05-046.md))
	- Evaluate if synchonization (locks) hurts the problem more than parallelism helps. ([s05-046](./memo/s05-046.md))
- **Problem 52**: Sharing global resource ([s05-042](./memo/s05-042.md))
- **Problem 53**: Spawning a fiber and waiting for it to complete ([s04-042](./memo/s04-042.md))
	- The coordination is achieved using channels, which act as a communication mechanism between fibers. ([s04-042](./memo/s04-042.md))
- **Problem 54**: Starvation ([s01-046](./memo/s01-046.md), [s02-025](./memo/s02-025.md), [s05-042](./memo/s05-042.md))
	- Implement a way for older, less prioritized threads to be processed. ([s01-046](./memo/s01-046.md))
	- Increase the priority of that particular transaction, use first come first serve approach. ([s02-025](./memo/s02-025.md))
	- Requires developing dependable strategies for coordinating their execution, data interchange, memory allocation, and execution schedule to decrease response time and maximize throughput. ([s05-042](./memo/s05-042.md))
- **Problem 55**: Synchronization issue ([s04-047](./memo/s04-047.md))
	- In es5, developers commonly used locks to prevent multiple processes from accessing shared resources simultaneously. however, locks can be difficult to manage, and if not implemented properly, can cause deadlocks. ([s04-047](./memo/s04-047.md))
- **Problem 56**: Temporary update ([s02-047](./memo/s02-047.md))
	- Locking involves acquiring locks on the data items used by transactions, preventing other transactions from accessing the same data until the lock is released. there are different types of locks, such as shared and exclusive locks, and they can be used to prevent dirty read and non-repeatable read. ([s02-047](./memo/s02-047.md))
- **Problem 57**: The complex coordination of authentication protocols in a network management application ([s04-033](./memo/s04-033.md))
	- Create a row for each mac address and protocol combination. ([s04-033](./memo/s04-033.md))
- **Problem 58**: The complexity and challenges associated with concurrent programming in java ([s01-033](./memo/s01-033.md))
	- In java8,they improvements and simplifications to make it easier to do concurrency. ([s01-033](./memo/s01-033.md))
- **Problem 59**: The complexity and difficulty associated with concurrent programming ([s02-033](./memo/s02-033.md))
	- The introduction of project loom, loom make performant java code accessible, particulatly those who struggle with the complexities of concurrent programming. ([s02-033](./memo/s02-033.md))
- **Problem 60**: The concurrency in software and systems engineering greatly increases complexity, make it to nondeterministic behavior and various type of concurrency defect ([s03-033](./memo/s03-033.md))
	- Develop test cases and testing techniques specifically designed to uncover concurrency defects in software and system. ([s03-033](./memo/s03-033.md))
- **Problem 61**: The confusion between the terms "concurrency" and "parallelism" ([s04-042](./memo/s04-042.md))
	- Acknowledge the definitions of "concurrency" and "parallelism". ([s04-042](./memo/s04-042.md))
- **Problem 62**: The difficulty and error-proneness of concurrent programming ([s04-009](./memo/s04-009.md))
	- Plan and design in advance: proper planning and designing of a concurrent system. ([s04-009](./memo/s04-009.md))
- **Problem 63**: The interference between concurrent features and object-oriented features in a programming language ([s05-009](./memo/s05-009.md))
	- A concurrency control mechanism based on the actor model that separates concurrency constraints from object code and introduces a lazy replacement scheme. ([s05-009](./memo/s05-009.md))
- **Problem 64**: The occurrence of race conditions in concurrency ([s04-033](./memo/s04-033.md))
	- Generating a unique identifier for each api request and associating it with the corresponding response. ([s04-033](./memo/s04-033.md))
- **Problem 65**: The potential loss of information or synchronization issues when using buffered channel ([s04-042](./memo/s04-042.md))
	- Ensuring that the receiving fiber is ready to consume values before the sending fiber proceeds. ([s04-042](./memo/s04-042.md))
- **Problem 66**: Thread hanging ([s04-046](./memo/s04-046.md))
	- If routine hangs while awaiting to send on a channel, increase channel capacity (buffer). ([s04-046](./memo/s04-046.md))
	- Allowing blocking operation to fail may cause the waiting party (i.e. the main thread) to hang. ([s04-046](./memo/s04-046.md))
- **Problem 67**: Uncommitted data ([s04-025](./memo/s04-025.md))
- **Problem 68**: Unrepeatable read ([s01-047](./memo/s01-047.md), [s02-046](./memo/s02-046.md), [s02-047](./memo/s02-047.md), [s05-047](./memo/s05-047.md))
	- Concurrency control protocols help to prevent the occurrence of above problems and maintain the consistency of the database. ([s01-047](./memo/s01-047.md))
	- Lock the resource while it is under operation. ([s02-046](./memo/s02-046.md))
	- Implement timestamping and allow or reject transactions based on the timestamps. ([s02-046](./memo/s02-046.md))
	- Implement validation protocol. ([s02-046](./memo/s02-046.md))
	- Concurrency control protocols  ensure consistency , atomicity, isolation, and serializability of concurrent transactions in a database. the concurrency control protocol  can be any of the following type. ([s05-047](./memo/s05-047.md))
	- Lock based concurrency control protocol. ([s05-047](./memo/s05-047.md))
	- Time-stamp concurrency control protocol. ([s05-047](./memo/s05-047.md))
	- Validation based concurrency control protocol. ([s05-047](./memo/s05-047.md))
- **Problem 69**: Users expect their systems to perform multiple tasks simultaneously such as downloading file ([s03-042](./memo/s03-042.md))
	- The java platform is designed to provide concurrency support to write efficient and responsive concurrent software. ([s03-042](./memo/s03-042.md))
- **Problem 70**: Visibility ([s05-033](./memo/s05-033.md))
	- Synchronization mechanisms can be used, such as locks or the synchronized keyword in java. these mechanisms ensure that changes made by one thread to shared data are visible to other threads. ([s05-033](./memo/s05-033.md))
- **Problem 71**: When running code, return order will be difference time ([s01-025](./memo/s01-025.md))
	- Collect respond as a list, then every time respond comes in, the entire list is refreshed with correct suggestion. ([s01-025](./memo/s01-025.md))
- **Problem 72**: When running the code, it is possible to encounter delays in generating output, such as when users type rapidly. it may lead to a perceived lack of responsiveness from the application ([s01-025](./memo/s01-025.md))
	- Using timestamps instead of a hash to address the delay issue when running the code. ([s01-025](./memo/s01-025.md))
## Decision Drivers
- A blocked process is waiting for some event, like the availability of a resource or completing an i/o operation ([s05-042](./memo/s05-042.md))
- A fiber is not executed as soon as it is spawned ([s04-042](./memo/s04-042.md))
- Bad code ([s04-046](./memo/s04-046.md))
- Blocking operation ([s04-046](./memo/s04-046.md))
- Can be caused by other running programs, other network traffic, operating system scheduling decisions, variations in processor clock speed, etc ([s01-042](./memo/s01-042.md))
- Channel direction that doesn't have these restrictions ([s02-042](./memo/s02-042.md))
- Code being executed has complex or time-consuming operations ([s01-025](./memo/s01-025.md))
- Complexity ([s01-033](./memo/s01-033.md))
- Computer users take it for granted that their systems can do more than one thing at a time ([s03-042](./memo/s03-042.md))
- Concurrency allows running several programs or parts of a program in parallel, which can lead to improved throughput and interactivity ([s05-033](./memo/s05-033.md))
- Concurrency control ([s05-003](./memo/s05-003.md))
- Concurrency control is crucial in dbms transactions to ensure data consistency and prevent concurrency problems ([s02-047](./memo/s02-047.md))
- Correctness ([s03-003](./memo/s03-003.md))
- Data integrity ([s01-032](./memo/s01-032.md), [s02-003](./memo/s02-003.md))
- Domain logic ([s03-003](./memo/s03-003.md))
- Don't have waiting time between after each one ([s02-042](./memo/s02-042.md))
- Each task have difference time to execute ([s01-025](./memo/s01-025.md))
- Errors in scheduling or mutual exclusion algorithm and resource leaks ([s05-042](./memo/s05-042.md))
- Fibers are spawned to perform concurrent tasks, and the main fiber waits for the spawned fibers to complete before proceeding further.for example, the main fiber invokes channel.receive and blocks until a value is received. meanwhile, the spawned fiber executes its code and sends a signal by invoking channel.send ([s04-042](./memo/s04-042.md))
- Have to control when multiple transactions execute concurrently ([s01-047](./memo/s01-047.md))
- Inconsistent ordering of operations ([s03-032](./memo/s03-032.md))
- Inefficient concurrency control ([s04-032](./memo/s04-032.md))
- Inefficient resource management ([s05-032](./memo/s05-032.md))
- Insufficient thread communication ([s04-032](./memo/s04-032.md))
- Interrupted or affected by other concurrent processes or threads ([s05-042](./memo/s05-042.md))
- It could be inefficient for the os to lock the resource and prevent other processes from using it ([s05-042](./memo/s05-042.md))
- It is challenging for the os to handle resource allocation properly ([s05-042](./memo/s05-042.md))
- It's difficult to spot a programming error because reports are usually repeatable due to the varying states of shared components each time the code is executed ([s05-042](./memo/s05-042.md))
- Java provides mechanisms like locks and thread synchronization to protect critical sections of code from simultaneous execution by multiple threads ([s05-033](./memo/s05-033.md))
- Lack of resource partitioning ([s05-032](./memo/s05-032.md))
- Lack of synchronization ([s03-032](./memo/s03-032.md), [s04-032](./memo/s04-032.md))
- Legacy code or existing design ([s04-032](./memo/s04-032.md))
- Liveness ([s03-003](./memo/s03-003.md))
- Low-priority process holds a resource that a high-priority process needs ([s02-025](./memo/s02-025.md))
- More processes or threads are waiting for each other to release resources ([s02-025](./memo/s02-025.md))
- Multi user or multi task access at the same time ([s04-025](./memo/s04-025.md))
- Multiple user access and use the same databasse at one time ([s03-025](./memo/s03-025.md))
- Occurs when one group member waits for another member, including itself, to send a message and release a lock ([s05-042](./memo/s05-042.md))
- Occurs when the output of a software application is determined by the timing or sequencing of other uncontrollable events, also happen in multithreaded software ([s05-042](./memo/s05-042.md))
- One user is trying to update data that another user has already updated ([s03-047](./memo/s03-047.md))
- Overlapping critical sections ([s05-032](./memo/s05-032.md))
- Performance ([s01-033](./memo/s01-033.md), [s04-033](./memo/s04-033.md), [s05-046](./memo/s05-046.md))
- Performance impact ([s01-032](./memo/s01-032.md))
- Process or thread cannot access the resource it needs to complete its task because other processes are hogging the resource ([s02-025](./memo/s02-025.md))
- Process or threads using shared resource ([s02-025](./memo/s02-025.md))
- Programming language ([s03-046](./memo/s03-046.md), [s04-046](./memo/s04-046.md), [s05-046](./memo/s05-046.md))
- Repeatable read level or higher : ensure that a transactions ca read the same set of rows consistetly, even if other transaction are updating the data simultaneouly ([s05-025](./memo/s05-025.md))
- Requirement ([s02-003](./memo/s02-003.md))
- Resource allocation ([s01-003](./memo/s01-003.md))
- Resource dependency ([s02-032](./memo/s02-032.md))
- Resource lock ([s01-046](./memo/s01-046.md), [s02-046](./memo/s02-046.md), [s03-046](./memo/s03-046.md), [s04-046](./memo/s04-046.md), [s05-046](./memo/s05-046.md))
- Resource reference ([s04-046](./memo/s04-046.md))
- Resource sharing ([s01-046](./memo/s01-046.md), [s02-046](./memo/s02-046.md), [s03-046](./memo/s03-046.md), [s04-046](./memo/s04-046.md), [s05-046](./memo/s05-046.md))
- Scalability ([s04-033](./memo/s04-033.md))
- Security against concurrency attack ([s04-003](./memo/s04-003.md))
- Sharing global resources is difficult. if two processes utilize a global variable and both alter the variable's value, the order in which the many changes are executed is critical ([s05-042](./memo/s05-042.md))
- Specific ([s04-033](./memo/s04-033.md))
- System architecture and design ([s03-032](./memo/s03-032.md))
- System complexity ([s01-032](./memo/s01-032.md))
- Task interaction ([s02-032](./memo/s02-032.md))
- The definitions of "concurrency" and "parallelism" sometimes get mixed up ([s04-042](./memo/s04-042.md))
- The event loop waits for that operation to finish the program ([s04-042](./memo/s04-042.md))
- The lack of awareness and training among  dev and tester regarding concurrency-related defect and techniques ([s03-033](./memo/s03-033.md))
- The need for a simpler and more accessible solution to concuurrency ([s02-033](./memo/s02-033.md))
- The requests made from web browsers and serves up html web pages in response ([s02-042](./memo/s02-042.md))
- The sending fiber continues executing without blocking because there is space in the buffer, it may perform additional send operations before the receiving fiber has a chance to consume the previously sent values ([s04-042](./memo/s04-042.md))
- There are situations where a single thread might not be enough to execute all the tasks efficiently ([s04-047](./memo/s04-047.md))
- Thread priority ([s01-046](./memo/s01-046.md))
- Timing and execution order ([s02-032](./memo/s02-032.md))
- Two or more users are trying to access the same data simultaneously, they may end up overwriting each otherâ€™s changes ([s03-047](./memo/s03-047.md))
- Two users try to edit the same data simultaneously ([s03-047](./memo/s03-047.md))
- Unbalanced workloads ([s05-032](./memo/s05-032.md))
- When a transaction reads some data-variable from the database-buffer and when it reads the same data-variable later, it finds that the data variable does not exist ([s05-047](./memo/s05-047.md))
- When multiple transactions execute simultaneously and updates from one or more transactions get lost ([s05-047](./memo/s05-047.md))
- When the uncommitted transaction is fail later on ([s05-047](./memo/s05-047.md))
- When there are different read values of the same variable occurs even when it has not updated its value ([s05-047](./memo/s05-047.md))
